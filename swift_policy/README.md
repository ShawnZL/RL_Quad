# Swift Policy

Pseudocode to train a policy to race through a race track, identify residual observation and dynamics models, and fine-tune the network on these residual 
models.

# core/QuadLearner

这段代码看起来是一个Python类`QuadLearner`的实现，该类似乎用于实现一个强化学习（RL）训练代理，该代理用于训练四轴飞行器（可能是一个无人机或机器人）执行某种任务。下面是对该类的主要部分进行的解释：

1. **初始化方法 `__init__`**:
   - 在初始化过程中，类接受一个名为`settings`的参数，该参数可能包含有关训练和环境设置的配置信息。
   - 类中定义了一些实例变量，如`config`（存储配置信息），`generate_wandb_log`和`use_tf_functions`等。
   - 根据配置信息，如果需要恢复以前的训练，则加载之前的模型检查点。
   - 创建了一个名为`summary_writer`的变量，该变量用于记录训练过程中的摘要信息。

2. **主要配置设置**:
   - 在初始化过程中，配置了一些训练的超参数和环境设置。这些设置包括PPO参数、轨迹布局、网络架构标志等。

3. **环境初始化**:
   - 在初始化过程中，创建了用于训练和评估的环境。这些环境共享相同的物理模拟，并模拟相同数量的代理。评估环境总是执行策略的贪婪（最优）动作。

4. **分布策略设置**:
   - 确定了用于分布策略的计算设备（例如CPU、GPU或TPU）。

5. **代理初始化**:
   - 创建了一个代理，该代理使用给定的配置信息、训练环境和训练步骤函数来初始化。

6. **训练方法 `train`**:
   - 这是主要的训练循环，它在固定的环境交互次数内进行训练。
   - 在每个训练迭代中，它会收集数据（例如，从环境中收集经验数据），然后根据收集的数据执行一定数量的训练步骤。
   - 训练步骤包括更新策略的权重以最小化损失，以优化性能。
   - 在某些迭代次数后，会进行测试运行以记录评估指标。
   - 每个迭代结束后，可能会清空回放缓冲区，为下一轮训练做准备。

7. **测试方法 `test`**:
   - 用于测试已经训练的策略在仿真环境中的性能。它记录测试指标并返回结果。

8. **识别残差模型方法 `identify_residual_models`**:
   - 包含两个子方法，分别是`identify_residual_observation`和`identify_residual_dynamics`，用于从在真实世界中收集的数据中识别残差模型。这些模型似乎是用于模拟环境中的不确定性或动态变化的。

总之，`QuadLearner`类是一个用于强化学习任务的Python类，它包括了环境初始化、训练、测试和残差模型识别等功能，用于培训四轴飞行器执行某种任务。在训练过程中，它采用了基于PPO的方法，并定期进行测试以评估性能。

# Environment/Quad3dEnvCPPVec

这段代码是一个Python类`Quad3dEnvCPPVec`的实现，看起来是一个用于RL训练的环境，用于模拟并控制多个四轴飞行器（quadrotors）的行为。以下是对该类的主要部分进行的解释：

1. **初始化方法 `__init__`**:
   - 初始化方法接受多个参数，包括`config`（可能包含有关环境设置的配置信息）、`create_logs`（用于控制是否创建日志记录）、`is_test_env`（指示是否为测试环境）、`verbose`（用于控制是否输出详细信息）等。
   - 在初始化过程中，可能会配置并启动一个并行化的仿真环境，该环境用于模拟多个四轴飞行器的行为。仿真环境似乎是基于称为"Agilicious"的四轴飞行器控制堆栈实现的，作者提供了相关的参考文献和代码链接。
   - 定义了观测（observation）和动作（action）的张量规范（tensor specs），使用了TF-Agents的嵌套张量格式来描述网络输入和输出的形状。

2. **`batched` 属性**:
   - 这个属性返回一个布尔值，指示环境是否支持批处理。在这里，它返回`True`，表示环境支持批处理。

3. **`batch_size` 属性**:
   - 这个属性返回批处理的大小，似乎是`num_envs`的值。

4. **`_reset` 方法**:
   - 这个方法用于重置所有环境的状态。在多个环境中，可以选择将无人机初始化在起始台或赛道上的随机门口。该方法返回一个`time_step_vec`，可能包含了初始时间步信息。

5. **`_step` 方法**:
   - 这个方法接受一个动作`action`，然后将该动作应用于所有环境中的四轴飞行器。它模拟了一个时间步，并计算了奖励（reward）等信息，然后返回一个`time_step_vec`，包含了时间步信息。

总之，`Quad3dEnvCPPVec`类是一个RL环境的实现，用于并行地模拟和控制多个四轴飞行器的行为。它包括了初始化、重置、步进等方法，用于与RL代理进行交互，以便进行训练和评估。该环境似乎是基于"Agilicious"四轴飞行器控制堆栈扩展而来，可以用于进行飞行器控制任务的研究和训练。

# nets/actor_net_racing

这段代码是一个名为`ActorNetRacing`的Python类的实现，看起来是一个用于构建策略网络（Actor Network）的类，通常用于强化学习中的策略概率分布。以下是对该类的主要部分进行的解释：

1. **初始化方法 `__init__`**:
   - 初始化方法接受多个参数，包括`observation_spec`（表示观测空间的规范）、`action_spec`（表示动作空间的规范）、`config`（可能包含有关网络配置的配置信息）、`name`（网络的名称，默认为"ActorNetwork"）等。
   - 在初始化过程中，似乎会定义网络的体系结构（architecture），包括密集层（dense layers）和投影网络（projection networks）。这些体系结构的具体定义可能来自于配置文件或论文中的描述。
   - 定义了属性`_output_tensor_spec`，该属性表示网络的输出规范，通常与动作空间的规范相对应。

2. **`output_tensor_spec` 属性**:
   - 这个属性返回了网络的输出规范，即网络生成的动作的规范。这个规范通常用于指导网络输出的形状和值范围。

3. **`call` 方法**:
   - 这个方法实现了网络的前向传播。它接受输入参数`observations`（观测数据）、`step_type`（时间步类型）、`network_state`（网络状态，可能用于循环神经网络）、`training`（表示是否处于训练模式的标志）、`mask`（掩码，用于处理序列数据）等。
   - 在方法内部，进行了网络的前向传播操作，并生成了输出动作`output_actions`。网络状态也可能在每个时间步更新。
   - 最后，将输出动作和网络状态作为结果返回。

总之，`ActorNetRacing`类是一个用于构建策略网络的类，通常在强化学习中用于定义策略概率分布。它包括了初始化方法、输出规范属性以及前向传播方法。具体的网络结构和行为可能根据配置信息和论文中的描述而定。这个类的实例通常用于构建强化学习代理的策略部分。

# nodes/rl_ros_node

这段代码定义了一个名为`RLPilot`的Python类，看起来是用于控制无人机（或机器人）在一种竞速环境中执行强化学习策略的控制器。以下是对该类的主要部分进行的解释：

1. **初始化方法 `__init__`**:
   - 初始化方法接受一个参数`log_dir`，似乎用于指定日志目录。
   - 在初始化过程中，可能会执行以下操作：
     - 初始化ROS节点（机器人操作系统节点）。
     - 加载策略网络（policy network），这个网络可能事先已经经过训练和保存。
     - 设置ROS话题（topics）的订阅者（subscribers）和发布者（publishers），以接收和发送数据。

2. **`reset_queue` 方法**:
   - 这个方法似乎用于将队列中的元素全部置零。

3. **`prepare_inputs` 方法**:
   - 这个方法可能用于准备网络的输入数据。首先，它将输入数据清零，然后将观测数据转换为符合策略网络所需的数据规范，并返回观测数据。

4. **`update_queue` 方法**:
   - 这个方法用于更新观测数据队列。它似乎将新的观测数据附加到队列中。

5. **`update_gate_progress` 方法**:
   - 这个方法可能用于更新竞速门的进度，以检查是否已通过某个竞速门。

6. **`print_rollout_summary` 方法**:
   - 这个方法似乎用于在完成一场竞速后打印摘要信息，并通过`rospy.signal_shutdown`来关闭ROS节点。

7. **`save_rollout_to_csv` 方法**:
   - 这个方法可能用于将竞速数据保存到CSV文件中，但在代码中没有具体实现。

8. **`odom_vio_callback` 方法**:
   - 这个方法可能是一个回调函数，用于处理来自里程计或视觉惯性测量单元（VIO）的数据，然后调用`generate_action`来生成控制命令。

9. **`generate_action` 方法**:
   - 这个方法可能是用于生成控制命令的核心部分。它可能包括以下步骤：
     - 将VIO数据组装成策略网络的观测数据。
     - 执行策略网络的前向传播，生成策略输出。
     - 解析策略网络的输出，以生成机器人的控制命令。
     - 发布生成的控制命令。
     - 更新竞速门的进度，以检查是否已通过。

10. **`start_callback` 方法**:
    - 这个方法似乎是一个回调函数，可能在开始发布控制命令时被调用。

最后，`if __name__ == "__main__":` 部分用于创建`RLPilot`的实例，并在ROS系统中保持运行状态（通过`rospy.spin()`），以便监听来自ROS节点的消息和事件。

总之，这段代码似乎是一个用于在ROS环境中控制竞速任务的Python类，通过强化学习策略生成控制命令，并与ROS系统进行交互以实现机器人的控制和竞速。

# utils/types/distort_equidist

这段代码包含两个函数 `distort_equidist` 和 `undistort_equidist`，它们似乎用于对使用等距摄像机模型（equidistant camera model）表示的图像点进行畸变（distortion）和去畸变（undistortion）操作。

1. `distort_equidist` 函数：
   - 这个函数接受三个参数：`points`（表示图像点的坐标，可能是一个NumPy数组或类似数据结构）、`K`（相机内参矩阵）和 `dist_coeffs`（畸变系数）。
   - 该函数的目标是对输入的图像点进行畸变，但在函数内部并没有实际的畸变操作。函数返回原始的输入 `points`，即不进行畸变处理。

2. `undistort_equidist` 函数：
   - 这个函数与前一个函数类似，接受相同的参数：`points`（表示图像点的坐标）、`K`（相机内参矩阵）和 `dist_coeffs`（畸变系数）。
   - 该函数的目标是对输入的图像点进行去畸变操作，但在函数内部并没有实际的去畸变操作。函数返回原始的输入 `points`，即不进行去畸变处理。

从代码中可以看出，这两个函数的实现目前并没有实际的畸变或去畸变操作，它们似乎只是占位符函数，可能是为了将来添加畸变操作而留下的函数框架。要执行实际的畸变或去畸变操作，需要在这两个函数的内部添加相应的数学计算或调用相应的库函数，以根据等距摄像机模型对图像点进行畸变或去畸变处理。

# utils/types/gate

这段代码定义了一个名为 `Gate` 的Python类，表示一个门或者关卡。以下是对该类的主要部分进行的解释：

1. **初始化方法 `__init__`**:
   - 初始化方法接受三个参数：`pos`（门的位置，通常是一个包含三个坐标的NumPy数组）、`att`（门的朝向或方向，通常是一个旋转矩阵或四元数表示）、`size`（门的大小，默认为1.45）。
   - 在初始化过程中，可以执行门的初始化操作。但在代码中，初始化操作部分被注释掉了，所以实际上并没有执行具体的初始化操作。

2. **`getCorners` 方法**:
   - 这个方法用于获取门的四个角点的坐标。
   - 方法内部使用 `np.concatenate` 函数将四个角点的坐标连接在一起，形成一个NumPy数组，然后返回该数组。

3. **`is_passed` 方法**:
   - 这个方法接受一个参数 `pos`，表示一个位置的坐标，通常是一个包含三个坐标的NumPy数组。
   
   - 方法的目标是检查给定的位置是否已经通过了门。具体的检查方式是通过门的朝向（`att`）将位置坐标变换，并检查变换后的坐标中的某个值是否大于0.05。如果大于0.05，则表示位置已通过门，方法返回 `True`，否则返回 `False`。
   
     > `Gate` 类中的 `is_passed` 方法用于检查给定的位置是否已经通过了门。下面是对该方法的详细解释：
     >
     > ```python
     > def is_passed(self, pos: np.ndarray) -> bool:
     >     return self.att.inverse.rotate(pos - self.pos)[0] > 0.05
     > ```
     >
     > 方法接受一个名为 `pos` 的参数，该参数通常是一个包含三个坐标的NumPy数组，表示某个位置的三维坐标。
     >
     > 方法的执行步骤如下：
     >
     > 1. `self.att.inverse`：首先，从 `Gate` 对象的属性 `self.att` 中获取门的朝向或方向。通常，`self.att` 可能是一个旋转矩阵或四元数，用于描述门的朝向。
     >
     > 2. `pos - self.pos`：然后，计算给定位置 `pos` 与门的位置 `self.pos` 之间的向量差。这个差向量表示从门的位置指向给定位置的方向和距离。
     >
     > 3. `.rotate`：接下来，将上述向量差应用于门的朝向，即使用门的朝向来旋转向量差。
     >
     > 4. `[0]`：最后，从旋转后的向量中提取第一个元素，即向量在门的朝向方向上的分量。
     >
     > 最终，方法返回一个布尔值（`True` 或 `False`）来表示给定的位置是否已经通过了门。具体地，如果向量在门的朝向方向上的分量大于0.05（假设门的过门阈值为0.05），则方法返回 `True`，表示位置已经通过了门；否则返回 `False`，表示位置没有通过门。这个方法主要用于竞速或导航任务中，以确定机器人是否已经成功通过了某个门。
     >
     > 按照我的理解，就是查看当前目标图像中，一点是否在门的范围之内，也就是查看摄像机的光轴是否是瞄准门的范围里
   
4. `__repr__` 方法:
   - 这个方法用于生成一个描述门的字符串。
   - 方法内部返回一个字符串，其中包含门的位置（x、y、z坐标）和门的偏航角（yaw，以度为单位）。

总之，`Gate` 类表示一个门或者关卡，它具有位置、朝向、大小等属性，并提供了方法用于获取门的角点坐标以及检查位置是否通过门。请注意，在代码中，门的初始化部分被注释掉了，所以需要在实际使用中将其初始化为具体的值。

# utils/types/track

这段代码定义了一个名为 `Track` 的Python类，表示一个赛道或轨道。这个类用于加载赛道的布局信息，包括门的位置和朝向，然后创建一个包含多个门对象的列表，以表示整个赛道。

以下是对 `Track` 类的主要部分进行的解释：

1. **初始化方法 `__init__`**:
   - 初始化方法接受多个参数，包括：
     - `track_layout_yaml`：赛道布局信息的YAML文件路径。
     - `gate_size`：门的大小，默认为1.45。
     - `gate_depth`：门的深度，默认为0.05。
     - `z_offset`：高度偏移，默认为0.0。
     - `yaw_offset`：偏航角偏移，默认为0.0。
   - 在初始化过程中，首先创建一个空列表 `self.gates` 用于存储赛道上的门对象。
   - 然后，代码尝试加载赛道布局信息从指定的YAML文件 `track_layout_yaml` 中。
   - 循环遍历赛道布局信息中的门（通过`track_yaml["gates"]["N"]`来确定门的数量），然后为每个门创建一个 `Gate` 对象，将门的位置和朝向传递给 `Gate` 的构造函数。
   - 创建的门对象被添加到 `self.gates` 列表中，以便后续使用。

总之，`Track` 类用于加载赛道的布局信息，创建赛道上的门对象，并将这些门对象存储在列表中。这使得可以轻松访问和操作赛道上的门，以进行赛道模拟或其他相关任务。在初始化中，赛道布局信息从YAML文件中读取，因此需要确保提供正确的文件路径。
